\section{Methods}
\par Shughni has multiple dictionary options, as we learned in the previous section. My choice fell for the dictionary made by \textcite{karamshoev_dict_1988} since it is the latest and the biggest dictionary. And moreover, researchers from the `Digital Resources for the Shughni Language' project \parencite{makarov_digital_2022} created an online Karamshoev's dictionary of the Shughni language. They granted me access to the underlying database from where it is easily possible to export all the needed lexemes and their meta information\todo{Добавьте пожалуйста, какого рода мета-информация важна для шугнанского словоизменения}.
\par Regarding the choice of the grammatical description, I have selected the one \todo{а почему только один? почему не все? я бы говорил main source} provided by \textcite{parker_shughni_2023} as the most suitable foundation for this study. This work offers an exceptionally thorough analysis of Shughni morphology including a very detailed inflectional paradigm description. In addition to this primary grammatical source, I also will be using the inside materials of the 2024 HSE expedition \todo{я думаю, что они дольше ездят и это достойно призанания здесь} to Khorog city, Tajikistan.
\par For the FST framework the choice fell for Helsinki Finite-State Technology (HFST). This is a modern tool set, it allows working with a wide range of compilers in a single shared FST format. Instead of built-in hfst-lexc I will be using LEXD compiler. Even thought it is not included into the HFST, it still produces transducers in HFST format. The choice between LEXC and LEXD was made in the latter's favor since it is a newer, more optimized and faster version of LEXC. The other option is Xerox's XFST compiler, which is a quite outdated option and was rarely used outside of Xerox. The advantage of LEXD is its tag system, which allows tagging stems and affixes, allowing to tune the combination of the lexemes with specific tags. This feature allows us to minimize overgeneration of unwanted FST paths.
\par For the matter of the morphonology part, HFST's implementation of TWOLC will be used. Shughni is not rich for morphonology, but it still has some rules like the insertion of \textit{'y'} on the phoneme border between two vowels, which is not possible to model using only a lexicon compiler.
\par The quality of the product morphological parser will be measured using two metrics: \textit{coverage}, and \textit{accuracy}. The \textit{coverage} is calculated as follows: \[coverage = \frac{N_{rec}}{N_{total}}\] where $N_{rec}$ is the amount of tokens, that the parser was able to recognize and return any output, and $N_{total}$ is the total amount of tokens. As of now, texts for \textit{coverage} evaluation are the Luke book of the Bible, a fairy tale and a collection of short miscellaneous texts with the total amount of 187149 tokens. All these texts were provided to me by \textcite{makarov_digital_2022}. The formula for \textit{accuracy} is: \[accuracy = \frac{N_{correct}}{N_{total}}\] where $N_{correct}$ is the amount of tokens for which the parser gave the same set of morphological tags as a human linguist did manually and $N_{total}$ is the total amount of manually tagged tokens. The manually tagged texts were also provided by `Digital resources for the Shughni Language' project. The tagged texts consist of 3453 tokens in total.
\par The core of the model will be written around Cyrillic stems and affixes. Then a separate FST for transliteration will be attached to the Cyrillic FSTs to make transducers that are able to work with Latin script.
\par The format of the tagged version of token \textit{`working'} will be \textit{`work<v>{}><inf>'}. Each tag is encapsulated into angular brackets and the morpheme border will be represented by a single 'greater than' or 'right angular bracket' sign. The tagged token \textit{`work<v>{}><inf>'} is an equivalent of \textit{`work.V-INF'} in standard linguistic notation. The motivation for morpheme `>` separator is that it is a standard for Apertium's systems and this format may be assumed by the outside user. This decision is not final since it brings complications with parsing of this format because this separator matches morpheme border bracket.